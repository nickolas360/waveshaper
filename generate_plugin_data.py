#!/usr/bin/env python3
# Copyright (C) 2017 taylor.fish <contact@taylor.fish>
#
# This file is part of Fish Waveshaper.
#
# Fish Waveshaper is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Fish Waveshaper is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Fish Waveshaper.  If not, see <http://www.gnu.org/licenses/>.

from collections import OrderedDict
import os

NUM_USER_POINTS = 6

SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
TTL_PATH = os.path.join(SCRIPT_DIR, "waveshaper.ttl")
C_PATH = os.path.join(SCRIPT_DIR, "ports.h")
INDENT = " " * 4

TTL_HEAD = """
# Copyright (C) 2017 taylor.fish <contact@taylor.fish>
#
# This file is part of Fish Waveshaper.
#
# Fish Waveshaper is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Fish Waveshaper is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Fish Waveshaper.  If not, see <http://www.gnu.org/licenses/>.

# This file was automatically generated by generate_plugin_data.py.

@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix lv2: <http://lv2plug.in/ns/lv2core#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix units: <http://lv2plug.in/ns/extensions/units#> .
@prefix pprops: <http://lv2plug.in/ns/ext/port-props#> .

<https://taylor.fish/plugins/waveshaper>
    a lv2:Plugin ;
    doap:name "Fish Waveshaper" ;
    doap:license <https://www.gnu.org/licenses/gpl-3.0.txt> ;
    doap:developer [
        a foaf:Person ;
        foaf:name "taylor.fish" ;
        foaf:mbox <mailto:contact@taylor.fish> ;
    ] ;
    doap:maintainer [
        a foaf:Person ;
        foaf:name "taylor.fish" ;
        foaf:mbox <mailto:contact@taylor.fish> ;
    ] ;
    lv2:optionalFeature lv2:hardRTCapable ;
    lv2:requiredFeature pprops:supportsStrictBounds ;
    lv2:port [
"""

C_HEAD = """
/*
 * Copyright (C) 2017 taylor.fish <contact@taylor.fish>
 *
 * This file is part of Fish Waveshaper.
 *
 * Fish Waveshaper is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Fish Waveshaper is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Fish Waveshaper.  If not, see <http://www.gnu.org/licenses/>.
 */

// This file was automatically generated by generate_plugin_data.py.

enum {
"""

X = """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "{symbol}_x" ;
lv2:name "{name} X" ;
lv2:default 0 ;
lv2:minimum 0 ;
lv2:maximum 1 ;
lv2:portProperty pprops:hasStrictBounds
"""

Y = """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "{symbol}_y" ;
lv2:name "{name} Y" ;
lv2:default 0 ;
lv2:minimum 0 ;
lv2:maximum 1 ;
lv2:portProperty pprops:hasStrictBounds
"""

TENSION = """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "{symbol}_tension" ;
lv2:name "{name} tension" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:default 0 ;
lv2:minimum -1 ;
lv2:maximum 1 ;
"""

TANGENT = """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "{symbol}_tangent{tan_num}" ;
lv2:name "{name} tan. {tan_num}" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:default 0 ;
lv2:minimum -5 ;
lv2:maximum 5 ;
"""

TYPE = """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "{symbol}_type" ;
lv2:name "{name} curve" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:portProperty lv2:integer ;
lv2:portProperty lv2:enumeration ;
lv2:scalePoint [ rdfs:label "Tension" ; rdf:value 1 ] ;
lv2:scalePoint [ rdfs:label "Tangents" ; rdf:value 0 ] ;
lv2:scalePoint [ rdfs:label "Linear" ; rdf:value 2 ] ;
lv2:default 1 ;
lv2:minimum 0 ;
lv2:maximum 2 ;
"""

END_POINT_Y = """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "end_point_y" ;
lv2:name "End point Y" ;
lv2:default 1 ;
lv2:minimum 0 ;
lv2:maximum 1 ;
lv2:portProperty pprops:hasStrictBounds
"""


OTHER_PORTS = OrderedDict([
    ("INPUT_L", """
a lv2:AudioPort ,
  lv2:InputPort ;
lv2:index {index} ;
lv2:symbol "in0" ;
lv2:name "InL"
"""),

    ("OUTPUT_L", """
a lv2:AudioPort ,
  lv2:OutputPort ;
lv2:index {index} ;
lv2:symbol "out0" ;
lv2:name "OutL"
"""),

    ("INPUT_R", """
a lv2:AudioPort ,
  lv2:InputPort ;
lv2:index {index} ;
lv2:symbol "in1" ;
lv2:name "InR"
"""),

    ("OUTPUT_R", """
a lv2:AudioPort ,
  lv2:OutputPort ;
lv2:index {index} ;
lv2:symbol "out1" ;
lv2:name "OutR"
"""),

    ("OVERSAMPLE", """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "oversample" ;
lv2:name "Oversample" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:portProperty lv2:integer ;
lv2:portProperty lv2:enumeration ;
lv2:scalePoint [ rdfs:label "Off" ; rdf:value 0 ] ;
lv2:scalePoint [ rdfs:label "2x" ; rdf:value 2 ] ;
lv2:scalePoint [ rdfs:label "4x" ; rdf:value 4 ] ;
lv2:scalePoint [ rdfs:label "8x" ; rdf:value 8 ] ;
lv2:scalePoint [ rdfs:label "16x" ; rdf:value 16 ] ;
lv2:default 0 ;
lv2:minimum 0 ;
lv2:maximum 16 ;
"""),

    ("INPUT_GAIN", """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "input_gain" ;
lv2:name "Input gain" ;
units:unit units:db ;
lv2:default 0 ;
lv2:minimum -40 ;
lv2:maximum 40 ;
"""),

    ("OUTPUT_GAIN", """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "output_gain" ;
lv2:name "Output gain" ;
units:unit units:db ;
lv2:default 0 ;
lv2:minimum -40 ;
lv2:maximum 40 ;
"""),

    ("DISPLAY_PLOT", """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "show_plot" ;
lv2:name "Show plot" ;
lv2:default 0 ;
lv2:portProperty lv2:toggled ;
"""),

    ("MONITOR_LEVELS", """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "monitor_levels" ;
lv2:name "Monitor levels" ;
lv2:default 0 ;
lv2:portProperty lv2:toggled ;
"""),

    ("ASYMMETRIC", """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "asymmetric" ;
lv2:name "Asymmetric" ;
lv2:default 0 ;
lv2:portProperty lv2:toggled ;
"""),

    ("INPUT_LEVEL", """
a lv2:OutputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "input_level" ;
lv2:name "Input level" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:portProperty lv2:connectionOptional ;
lv2:default 0 ;
lv2:minimum 0 ;
lv2:maximum 1 ;
"""),

    ("INPUT_CLIP", """
a lv2:OutputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "input_clip" ;
lv2:name "Input clip" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:portProperty lv2:connectionOptional ;
lv2:default 0 ;
lv2:minimum 0 ;
lv2:maximum 1 ;
"""),

    ("OUTPUT_LEVEL", """
a lv2:OutputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "output_level" ;
lv2:name "Output level" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:portProperty lv2:connectionOptional ;
lv2:default 0 ;
lv2:minimum 0 ;
lv2:maximum 1 ;
"""),

    ("OUTPUT_0DB", """
a lv2:OutputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "output_0db" ;
lv2:name "Output 0dB" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:portProperty lv2:connectionOptional ;
lv2:default 0 ;
lv2:minimum 0 ;
lv2:maximum 1 ;
"""),
])


class Writer:
    def __init__(self, ttl_path, c_path):
        self.index = 0
        self.ttl_file = open(ttl_path, "w")
        self.c_file = open(c_path, "w")

    def port(self, c_name, template, first=False, **kwargs):
        if not first:
            self.ttl_raw(INDENT + "] , [")

        self.ttl_raw(INDENT * 2 + template.strip().format(
            index=self.index, **kwargs,
        ).replace("\n", "\n" + INDENT * 2))

        if c_name:
            self.const("PORT_" + c_name, self.index)
        self.index += 1

    def const(self, c_name, val):
        self.c_raw(INDENT + "{} = {},".format(c_name, val))

    def ttl_raw(self, text, **kwargs):
        print(text, file=self.ttl_file, **kwargs)

    def c_raw(self, text, **kwargs):
        print(text, file=self.c_file, **kwargs)

    def close(self):
        pass

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.ttl_file.close()
        self.c_file.close()


def generate_files(writer):
    w = writer
    w.ttl_raw(TTL_HEAD.strip())
    w.c_raw(C_HEAD.strip())
    w.const("NUM_USER_POINTS", NUM_USER_POINTS)
    w.port("END_POINT_Y", END_POINT_Y, first=True)

    symbol, name = "origin", "Origin"
    w.const("MIN_ORIGIN_PORT", w.index)
    w.port(None, TENSION, symbol=symbol, name=name)
    w.port(None, TANGENT, symbol=symbol, name=name, tan_num=1)
    w.port(None, TANGENT, symbol=symbol, name=name, tan_num=2)
    w.port(None, TYPE, symbol=symbol, name=name)
    w.const("MAX_ORIGIN_PORT", w.index - 1)

    w.const("MIN_POINT_PORT", w.index)
    for i in range(1, NUM_USER_POINTS + 1):
        symbol = "point{}".format(i)
        name1 = "Point {}".format(i)
        name2 = "Pt. {}".format(i)
        w.port(None, X, symbol=symbol, name=name1)
        w.port(None, Y, symbol=symbol, name=name1)
        w.port(None, TENSION, symbol=symbol, name=name2)
        w.port(None, TANGENT, symbol=symbol, name=name2, tan_num=1)
        w.port(None, TANGENT, symbol=symbol, name=name2, tan_num=2)
        w.port(None, TYPE, symbol=symbol, name=name2)
    w.const("MAX_POINT_PORT", w.index - 1)

    symbol, name = "asym", "Asym."
    w.const("MIN_ASYM_PORT", w.index)
    w.port(None, Y, symbol=symbol, name=name)
    w.port(None, TENSION, symbol=symbol, name=name)
    w.port(None, TANGENT, symbol=symbol, name=name, tan_num=1)
    w.port(None, TANGENT, symbol=symbol, name=name, tan_num=2)
    w.port(None, TYPE, symbol=symbol, name=name)
    w.const("MAX_ASYM_PORT", w.index - 1)

    for c_name, template in OTHER_PORTS.items():
        w.port(c_name, template)

    w.ttl_raw(INDENT + "] .")
    w.c_raw("};")


def main():
    with Writer(TTL_PATH, C_PATH) as writer:
        generate_files(writer)

if __name__ == "__main__":
    main()
